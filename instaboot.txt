
getting started

scope
	create post
		- has text content
		- has one image
		- has zero-to-many comments

	system will create a thumbnail for the image

	system will display x number of "latest" images on the home page


create project

create new spring initializr project
    group: org.mrpaulwoods
    artifact: instaboot
    type: gradle project
    language: groovy
    packagin: war
    java version: 1.8

	dependencies:
        core: security, devtools
        web: web
        template engines: thymeleaf
        sql: jpa, h2
        ops: Actuator

	check use auto-import


hello world


create home.HomeController

    package org.mrpaulwoods.instaboot.home

    import groovy.util.logging.Slf4j
    import org.springframework.stereotype.Controller
    import org.springframework.web.bind.annotation.GetMapping
    import org.springframework.web.bind.annotation.RequestMapping

    @Slf4j
    @Controller
    @RequestMapping
    class HomeController {

        @GetMapping
        String index() {
            "home/index"
        }
    }


create home/index.html

    <!DOCTYPE html>

    <html   xmlns:layout="http://www.w3.org/1999/xhtml"
            xmlns="http://www.w3.org/1999/xhtml">

    <body>

        <h1>Hello World</h1>

    </body>

    </html>


hello world
	- security user = "user"
	- password is displayed in the log file







Paul's Practices
    no List<Child> children in the domain objects
    - there nothing wrong with doing this. but you may end up with some
       ugly circular dependencies when serializing to json/xml/...


        one package per
            domain
            feature
            this leads to a lot of packages, with one or just a few classes inside
            advantage is that if a domain/feature needs to change, its easy to find the classes

    repositories are DMZ objects between the app and the data
        - only accessed by services
        - access database, rest endpoints, external configuration files, ...
        - speak the language of the data source

    services
        - translate the language of the data source to the language of the application
        - usually only access one domain
        - exceptions - may access parent or child domains

    why - so if a datasource changes, the repository should be the only thing that changes
        - in some cases, the service will need to change
        - isolates changes to a small footprint of code.

    one class for each complex user action
        suffix = Action, package = action
        keeps the complex code isolated
        makes it easy compose complete actions made up of other simpler actions

    first, make it work. then make it work better.
        - don't worry about performance issues and perfect algorithms at the beginning.
        - make it work first. let the user's test it, and improve where necessary.


instaboot model
	post
	has many images. each image has a type (original, thumbnail)
	has many comments.


basic spring data
	creating jpa entities
	creating repositories


package org.mrpaulwoods.instaboot.post

import org.mrpaulwoods.instaboot.image.Image
import org.mrpaulwoods.instaboot.security.user.User

import javax.persistence.Column
import javax.persistence.Entity
import javax.persistence.GeneratedValue
import javax.persistence.Id
import javax.persistence.JoinColumn
import javax.persistence.ManyToOne

@Entity
class Post implements Serializable {

    private static final long serialVersionUID = 0

    @GeneratedValue
    @Id
    Long id

    @ManyToOne
    @JoinColumn(name="user_id")
    User user

    @Column(length=2000)
    String text
}

package org.mrpaulwoods.instaboot.image

import org.mrpaulwoods.instaboot.post.Post
import org.mrpaulwoods.instaboot.security.user.User

import javax.persistence.Column
import javax.persistence.Entity
import javax.persistence.EnumType
import javax.persistence.Enumerated
import javax.persistence.GeneratedValue
import javax.persistence.Id
import javax.persistence.JoinColumn
import javax.persistence.Lob
import javax.persistence.ManyToOne

@Entity
class Image implements Serializable {

    private static final long serialVersionUID = 0

    @GeneratedValue
    @Id
    Long id

    @ManyToOne
    @JoinColumn(name="user_id")
    User user

    @ManyToOne
    @JoinColumn(name="post_id")
    Post post

    @Lob
    @Column(length = 4194304) // 4MB
    byte[] content

    @Column(length = 300)
    String name

    @Column(length = 200)
    String contentType

    @Enumerated(EnumType.STRING)
    @Column(length = 50)
    ImageType imageType
}

package org.mrpaulwoods.instaboot.comment

import org.mrpaulwoods.instaboot.post.Post
import org.mrpaulwoods.instaboot.security.user.User

import javax.persistence.Column
import javax.persistence.Entity
import javax.persistence.GeneratedValue
import javax.persistence.Id
import javax.persistence.JoinColumn
import javax.persistence.ManyToOne

@Entity
class Comment implements Serializable {

    private static final long serialVersionUID = 0

    @GeneratedValue
    @Id
    Long id

    @ManyToOne
    @JoinColumn(name="user_id")
    User user

    @ManyToOne
    @JoinColumn(name = "post_id")
    Post post

    @Column(length = 2000)
    String text
}


create services
	services generally access one datasource
        create
        read
        update
        delete
        list
        findByXyz
        findAllByXyz


actions
	access multiple services to perform a user's task


upload image
	create upload controller
	create upload.html
	create UploadForm
	    -why forms and not entities

	create upload action
	create uploadCreate action

	create post
	create image
		- refactor into UploadAction


    upload.UploadForm

    package org.mrpaulwoods.instaboot.upload

    import groovy.transform.Canonical
    import org.springframework.web.multipart.MultipartFile

    import javax.validation.constraints.NotNull
    import javax.validation.constraints.Size

    @Canonical

    class UploadForm implements Serializable {

        private static final long serialVersionUID = 0

        MultipartFile content

        @NotNull
        @Size(min=1, max=2000)
        String text

        boolean hasContent() {
            !content.empty
        }

    }



    upload.UploadController

    package org.mrpaulwoods.instaboot.upload

    import groovy.util.logging.Slf4j
    import org.mrpaulwoods.instaboot.action.UploadAction
    import org.mrpaulwoods.instaboot.image.ImageService
    import org.mrpaulwoods.instaboot.security.SecurityService
    import org.springframework.security.access.prepost.PreAuthorize
    import org.springframework.stereotype.Controller
    import org.springframework.ui.Model
    import org.springframework.validation.BindingResult
    import org.springframework.web.bind.annotation.GetMapping
    import org.springframework.web.bind.annotation.PostMapping
    import org.springframework.web.bind.annotation.RequestMapping

    import javax.validation.Valid

    @Slf4j
    @Controller
    @RequestMapping("/upload")
    class UploadController {

        private ImageService imageService
        private UploadAction uploadAction
        private SecurityService securityService

        UploadController(
                ImageService imageService,
                UploadAction uploadAction,
                SecurityService securityService
        ) {
            this.imageService = imageService
            this.uploadAction = uploadAction
            this.securityService = securityService
        }

        @GetMapping
        @PreAuthorize("hasRole(['ROLE_USER])")
        String index(final Model model) {
            model.addAttribute "uploadForm", new UploadForm()
            "upload/index"
        }

        @PostMapping("/create")
        @PreAuthorize("hasRole(['ROLE_USER])")
        String create(@Valid UploadForm uploadForm, BindingResult result) {
            if (result.hasErrors()) {
                "upload/index"
            } else if (!uploadForm.hasContent()) {
                "upload/index"
            } else {
                uploadAction.execute uploadForm, securityService.currentUser
                "redirect:/"
            }
        }

    }


    action.UploadAction

    package org.mrpaulwoods.instaboot.action

    import groovy.util.logging.Slf4j
    import org.mrpaulwoods.instaboot.image.Image
    import org.mrpaulwoods.instaboot.image.ImageService
    import org.mrpaulwoods.instaboot.image.ImageType
    import org.mrpaulwoods.instaboot.post.Post
    import org.mrpaulwoods.instaboot.post.PostService
    import org.mrpaulwoods.instaboot.security.user.User
 //   import org.mrpaulwoods.instaboot.thumbnail.ThumbnailService
    import org.mrpaulwoods.instaboot.upload.UploadForm
    import org.springframework.stereotype.Service
    import org.springframework.transaction.annotation.Transactional

    @Slf4j
    @Service
    @Transactional
    class UploadAction {

        private ImageService imageService
        private PostService postService
        //private ThumbnailService thumbnailService

        UploadAction(
                ImageService imageService,
                PostService postService
                //ThumbnailService thumbnailService
        ) {
            this.imageService = imageService
            this.postService = postService
           // this.thumbnailService = thumbnailService
        }

        Post execute(UploadForm uploadForm, User user) {

            execute uploadForm.content.originalFilename,
                    uploadForm.content.contentType,
                    uploadForm.content.bytes,
                    uploadForm.text,
                    user
        }

        Post execute(String name, String contentType, byte[] content, String text, User user) {

            Post post = postService.create(new Post(
                    text: text,
                    user: user
            ))

            Image image = imageService.create(new Image(
                    post: post,
                    name: name,
                    contentType: contentType,
                    content: content,
                    imageType: ImageType.ORIGINAL,
                    user: user
            ))

            // thumbnailService.execute image

            post
        }

    }


configure tomcat to handle 4mb uploads
	application.properties
	spring.http.multipart.max-file-size=4194304


bootstrap
	create some dummy posts,images,comments



    package org.mrpaulwoods.instaboot

    import groovy.util.logging.Slf4j
    import org.mrpaulwoods.instaboot.action.UploadAction
    import org.mrpaulwoods.instaboot.comment.Comment
    import org.mrpaulwoods.instaboot.comment.CommentService
    import org.mrpaulwoods.instaboot.post.Post
    import org.mrpaulwoods.instaboot.security.SecurityService
    import org.mrpaulwoods.instaboot.security.authority.Authority
    import org.mrpaulwoods.instaboot.security.authority.AuthorityService
    import org.mrpaulwoods.instaboot.security.user.User
    import org.mrpaulwoods.instaboot.security.user.UserService
    import org.springframework.core.io.ClassPathResource
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
    import org.springframework.stereotype.Service
    import org.springframework.transaction.annotation.Transactional
    import javax.annotation.PostConstruct

    @Slf4j
    @Service
    @Transactional
    class Bootstrap {

        private UploadAction uploadAction
        private CommentService commentService
        private SecurityService securityService

        Bootstrap(
                UploadAction uploadAction,
                CommentService commentService,
                SecurityService securityService
        ) {
            this.uploadAction = uploadAction
            this.commentService = commentService
            this.securityService = securityService
        }

        @PostConstruct
        void init() {

            User user = securityService.register("mr.paul.woods@gmail.com", "11111")

            Post post1 = uploadAction.execute(
                    "all code is guilty until proven innocent",
                    "image/png",
                    new ClassPathResource("01.png").inputStream.bytes,
                    "anonymous quote",
                    user
            )

            commentService.create(new Comment(
                    post: post1,
                    text: "This is the first comment.",
                    user: user
            ))

            commentService.create(new Comment(
                    post: post1,
                    text: "This is the second comment.",
                    user: user
            ))

            Post post2 = uploadAction.execute(
                    "hello world",
                    "image/png",
                    new ClassPathResource("02.png").inputStream.bytes,
                    "when a geek is born",
                    user
            )

            commentService.create(new Comment(
                    post: post2,
                    text: "This is the third comment.",
                    user: user
            ))

            commentService.create(new Comment(
                    post: post2,
                    text: "This is the fourth comment.",
                    user: user
            ))

        }

    }

update home page to show multiple images

    home.HomeController

    @GetMapping
    String index(final Model model) {
        model.addAttribute "posts", postService.list()
        "home/index"
    }


    home/index.html

    <h4>Latest Images</h4>

    <div style="display: inline-block; margin: 1em; padding: 1em;" th:each="post : ${posts}">
        <a th:href="@{/post/show/{id}(id=${post.id})}">
            <img src="#" th:src="@{/image/content/{id}(id=${@imageService.fetchThumbnailImage(post).id})}"/>
        </a>
        <div th:text="${post.user.username}"></div>
        <div th:text="${@imageService.fetchThumbnailImage(post).name}"></div>
    </div>


add thumbnail service
	
	compile 'net.coobird:thumbnailator:0.4.8'
	
	update UploadAction to call thumbnailService.execute image

	package org.mrpaulwoods.instaboot.thumbnail

	import groovy.util.logging.Slf4j
	import net.coobird.thumbnailator.Thumbnails
	import org.mrpaulwoods.instaboot.image.Image
	import org.mrpaulwoods.instaboot.image.ImageService
	import org.mrpaulwoods.instaboot.image.ImageType
	import org.springframework.stereotype.Service
	import org.springframework.transaction.annotation.Transactional

	@Slf4j
	@Service
	@Transactional
	class ThumbnailService {

	    private ImageService imageService

	    ThumbnailService(
	            ImageService imageService
	    ) {
	        this.imageService = imageService
	    }

	    Image execute(Image image) {

	        ByteArrayInputStream bais = new ByteArrayInputStream(image.content)
	        ByteArrayOutputStream baos = new ByteArrayOutputStream()

	        Thumbnails
	                .of(bais)
	                .size(120,120)
	                .toOutputStream(baos)

	        Image image2 = imageService.create(new Image(
	                post: image.post,
	                name: image.name,
	                contentType: image.contentType,
	                content: baos.toByteArray(),
	                imageType: ImageType.THUMBNAIL,
	                user: image.user
	        ))

	        image2
	    }

	}



click on image goes to its show page

    post.PostController

    @GetMapping("/show/{id}")
    @PreAuthorize("permitAll")
    String show(@PathVariable Long id, final Model model) {
        Post post = postService.fetch(id)
        model.addAttribute "post", post
        model.addAttribute "image", imageService.fetchOriginalImage(post)
        model.addAttribute "comments", commentService.findAllByPost(post)
        model.addAttribute "commentForm", new CommentForm(postId: post.id)
        "post/show"
    }



    post/show.html

    <!DOCTYPE html>

    <html
            xmlns:layout="http://www.w3.org/1999/xhtml"
            xmlns="http://www.w3.org/1999/xhtml"
            xmlns:th="http://www.thymeleaf.org"
            layout:decorator="instaboot">

    <body>

    <div layout:fragment="body">

        <h2 th:text="${image.name}"></h2>

        <div class="row">
            <div class="col-md-8">
                <img th:src="@{/image/content/{id}(id=${image.id})}"/>
            </div>
            <div class="col-md-4">

                <div th:text="${post.user.username}"></div>
                <div th:text="${post.text}"></div>

                <hr/>

                <div>

                    <form th:action="@{/comment/save/{id}(id=${post.id})}" method="post" th:object="${commentForm}">

                        <div class="form-group">
                            <label>Add Comment</label>
                            <textarea  class="form-control" th:field="*{text}"></textarea>
                        </div>

                        <div class="form-group">
                            <input  class="form-control" type="hidden" th:field="*{postId}"/>
                        </div>

                        <div>
                            <button class="btn btn-primary">Add</button>
                        </div>

                    </form>

                </div>

                <hr/>

                <h4>Comments</h4>

                <div th:each="comment : ${comments}">
                    <div th:text="${comment.user.username}"></div>
                    <div th:text="${comment.text}"></div>
                    <br/>
                </div>

            </div>

        </div>

    </div>

    </body>

    </html>


    comment.CommentController


    @RequestMapping("/save/{postId}")
    @PreAuthorize("hasRole(['ROLE_USER])")
    String save(@PathVariable Long postId, @Valid CommentForm commentForm, BindingResult result, final Model model) {
        Post post = postService.fetch(postId)
        if(result.hasErrors()) {
            model.addAttribute "post", post
            model.addAttribute "image", imageService.fetchOriginalImage(post)
            model.addAttribute "comments", commentService.findAllByPost(post)
            model.addAttribute "commentForm", new CommentForm(postId: post.id)
            "post/show"
        } else {
            commentService.create new Comment(
                    post: post,
                    text: commentForm.text,
                    user: securityService.currentUser)
            "redirect:/post/show/$postId"
        }
    }




update ui to bootstrap
    compile 'org.webjars:jquery:3.2.1'
	compile 'org.webjars:bootstrap:3.3.7-1'

	instaboot.html

	<!DOCTYPE html>

	<html lang="en"
	      xmlns:th="http://www.thymeleaf.org"
	      xmlns:layout="http://www.w3.org/1999/xhtml"
	      xmlns="http://www.w3.org/1999/xhtml">

	<head>
	    <meta charset="utf-8"/>
	    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>
	    <title>Insta Boot</title>
	    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	    <link rel="stylesheet" th:href="@{/webjars/bootstrap/3.3.7-1/css/bootstrap.min.css}"/>
	    <link rel="stylesheet" th:href="@{/css/styles.css}"/>

	</head>

	<body>

	<nav class="navbar navbar-default">
	    <div class="container-fluid">
	        <div class="navbar-header">
	            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
	                <span class="sr-only">Toggle navigation</span>
	                <span class="icon-bar"></span>
	                <span class="icon-bar"></span>
	                <span class="icon-bar"></span>
	            </button>
	            <a class="navbar-brand" th:href="@{/}">InstaBoot Images</a>
	        </div>
	        <div id="navbar" class="navbar-collapse collapse">
	            <ul class="nav navbar-nav">
	                <li><a th:href="@{/}">Home</a></li>
	                <li><a th:href="@{/upload}">Upload</a></li>
	            </ul>
	            <ul class="nav navbar-nav navbar-right">
	                <li th:if="${#authentication.name == 'anonymousUser'}"><a th:href="@{/login}">login</a></li>
	                <li th:if="${#authentication.name != 'anonymousUser'}"><a th:href="@{/logout}" th:text="${#authentication.name}">user name</a></li>
	            </ul>
	        </div><!--/.nav-collapse -->
	    </div><!--/.container-fluid -->
	</nav>

	<div class="container-fluid">
	    <div layout:fragment="body"></div>
	</div>

	<script th:src="@{/webjars/jquery/3.2.1/jquery.min.js}"></script>
	<script th:src="@{/webjars/bootstrap/3.3.7-1/js/bootstrap.min.js}"></script>

	</body>

	</html>


	home/index.html
	<!DOCTYPE html>

	<html
	        xmlns:layout="http://www.w3.org/1999/xhtml"
	        xmlns="http://www.w3.org/1999/xhtml"
	        xmlns:th="http://www.thymeleaf.org"
	        layout:decorator="instaboot">

	<body>

	<div layout:fragment="body">

	    <div class="row">
	        <div class="col-md-12">
	            <h2 class="text-center">Welcome To InstaBoot</h2>
	        </div>
	    </div>

	    <h4>Latest Images</h4>

	    <div style="display: inline-block; margin: 1em; padding: 1em;" th:each="post : ${posts}">
	        <a th:href="@{/post/show/{id}(id=${post.id})}">
	            <img src="#" th:src="@{/image/content/{id}(id=${@imageService.fetchThumbnailImage(post).id})}"/>
	        </a>
	        <div th:text="${post.user.username}"></div>
	        <div th:text="${@imageService.fetchThumbnailImage(post).name}"></div>
	    </div>

	</div>

	</body>

	</html>


unit tests

	testCompile('org.spockframework:spock-core:1.1-groovy-2.4') {
		exclude module: 'groovy-all'
	}
	testCompile('org.spockframework:spock-spring:1.1-groovy-2.4') {
		exclude module: 'groovy-all'
	}
	testCompile 'cglib:cglib-nodep:3.2.5'
	testCompile 'org.objenesis:objenesis:2.5.1'

jacoco


    apply plugin: 'jacoco'

    jacoco {
        reportsDir = file("$buildDir/reports/jacoco")
    }




update security

	compile('org.thymeleaf.extras:thymeleaf-extras-springsecurity4')
